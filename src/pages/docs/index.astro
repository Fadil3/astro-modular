---
import { getEntry } from 'astro:content';
import { siteConfig } from '@/config';
import { generatePostsListSEO } from '@/utils/seo';
import { fetchStrapiDocs } from '@/utils/strapi';
import BaseLayout from '@/layouts/BaseLayout.astro';
import PageLayout from '@/layouts/PageLayout.astro';
import StrapiDocCard from '@/components/StrapiDocCard.astro';
import TableOfContents from '@/components/TableOfContents.astro';
import Icon from '@/components/Icon.astro';

export const prerender = false;

// Check if docs are enabled and handle fallback
let fallbackPage = null;

if (!siteConfig.optionalContentTypes.docs) {
  // Check for fallback page in pages collection
  try {
    fallbackPage = await getEntry('pages', 'docs');
    if (fallbackPage) {
      // PageLayout will handle the rendering
    } else {
      return Astro.redirect('/404');
    }
  } catch (error) {
    // No fallback page found, redirect to 404
    return Astro.redirect('/404');
  }
}

// Get all docs from Strapi
const locale = Astro.currentLocale || 'en';
const allDocs = await fetchStrapiDocs({ locale });

// Get docs page content from special collection
let docsPageContent = null;
let docsPageHideTOC = false;
let DocsPageContent = null;

try {
  docsPageContent = await getEntry('special', 'docs');
  if (docsPageContent) {
    const { Content } = await docsPageContent.render();
    DocsPageContent = Content;
    docsPageHideTOC = docsPageContent.data.hideTOC === true;
  }
} catch (error) {
  // Fallback to default if docs.md doesn't exist
}

// Check if any docs have categories
const docsHaveCategories = allDocs.some(doc => doc.category);

// Group docs by category or list them without categories
let docsByCategory: Record<string, typeof allDocs>;
let sortedCategories: string[];
let tocHeadings: any[];
let shouldShowTOC: boolean;

if (docsHaveCategories) {
  // Group docs by category
  docsByCategory = allDocs.reduce((acc, doc) => {
    const category = doc.category || 'Unsorted';
    if (!acc[category]) acc[category] = [];
    acc[category].push(doc);
    return acc;
  }, {} as Record<string, typeof allDocs>);
  
  // Sort categories and docs within each category
  sortedCategories = Object.keys(docsByCategory).sort();
  sortedCategories.forEach(category => {
    docsByCategory[category].sort((a, b) => (a.order || 999) - (b.order || 999));
  });
  
  // Generate TOC headings from categories
  tocHeadings = sortedCategories.map(category => ({
    depth: 2,
    slug: `category-${category.toLowerCase().replace(/\s+/g, '-')}`,
    text: category
  }));
} else {
  // No categories - just list docs by order
  docsByCategory = { 'All Documentation': allDocs.sort((a, b) => (a.order || 999) - (b.order || 999)) };
  sortedCategories = ['All Documentation'];
  tocHeadings = [];
}

// Show TOC if not hidden and there are headings to show
shouldShowTOC = !docsPageHideTOC && tocHeadings.length > 0;


// Generate SEO data
const seoData = generatePostsListSEO(Astro.site?.toString() || '', undefined);
seoData.title = docsPageContent?.data.title ? `${docsPageContent.data.title} | ${siteConfig.title}` : `Documentation | ${siteConfig.title}`;
seoData.description = docsPageContent?.data.description || `Browse all documentation on ${siteConfig.title}`;
seoData.noIndex = (docsPageContent?.data as any)?.noIndex || false;
---

{fallbackPage ? (
  <PageLayout page={fallbackPage as any} />
) : (
<BaseLayout seoData={seoData}>
  <div class="py-8 relative">
    <div class="mx-auto px-4 sm:px-6 lg:px-8" style={`max-width: ${siteConfig.layout.contentWidth}`}>
      <!-- Page header -->
      <header class="mb-8">
        <h1 class="text-lg font-bold text-primary-900 dark:text-primary-50 mb-3">
          {docsPageContent?.data.title || 'Documentation'}
        </h1>
        {DocsPageContent ? (
          <div class="prose prose-sm dark:prose-dark max-w-none">
            <DocsPageContent />
          </div>
        ) : (
          <p class="text-primary-600 dark:text-primary-300">
            Guides, tutorials, and reference materials
          </p>
        )}
      </header>

      <!-- Documentation by category -->
      {sortedCategories.length > 0 ? (
        <div class="relative">
          <div class="space-y-12">
            {sortedCategories.map(category => (
              <section id={`category-${category.toLowerCase().replace(/\s+/g, '-')}`}>
                {docsHaveCategories && (
                  <h2 class="text-lg font-semibold text-primary-900 dark:text-primary-50 mb-6 pb-2 border-b border-primary-200 dark:border-primary-700">
                    <a href={`#category-${category.toLowerCase().replace(/\s+/g, '-')}`} class="anchor-link text-primary-900 dark:text-primary-50 hover:text-highlight-600 dark:hover:text-highlight-400 no-underline transition-colors duration-200" aria-label="Link to this section">
                      {category}
                    </a>
                  </h2>
                )}
              
              <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {docsByCategory[category].map((doc, index) => (
                  <StrapiDocCard 
                    doc={doc} 
                    eager={index === 0}
                    showImage={false}
                  />
                ))}
              </div>
              </section>
            ))}
          </div>

        </div>

        <!-- Desktop TOC - floats to the right of the content container -->
        {shouldShowTOC && (
          <div class="hidden xl:block absolute top-0 left-full ml-1 w-64">
            <div class="sticky top-24" id="toc">
              <TableOfContents headings={tocHeadings} />
            </div>
          </div>
        )}
      ) : (
        <div class="text-center py-12">
          <Icon name="book-open" class="w-12 h-12 text-primary-300 dark:text-primary-600 mx-auto mb-4" />
          <h3 class="text-lg font-medium text-primary-900 dark:text-primary-50 mb-2">
            No documentation yet
          </h3>
          <p class="text-primary-600 dark:text-primary-300">
            Check back soon for guides and tutorials!
          </p>
        </div>
      )}
    </div>
  </div>

  <Fragment slot="scripts">
    <script>
      // Custom scroll behavior for documentation categories
      document.addEventListener('DOMContentLoaded', () => {
        const tocLinks = document.querySelectorAll('.toc-link');
        const categorySections = document.querySelectorAll('section[id^="category-"]');
        
        if (!tocLinks.length || !categorySections.length) return;
        
        // Enhanced highlight function for categories
        function highlightTOC() {
          let current = '';
          
          categorySections.forEach(section => {
            const rect = section.getBoundingClientRect();
            // More precise threshold for categories
            if (rect.top <= 120) {
              current = section.id;
            }
          });
          
          tocLinks.forEach(link => {
            const href = link.getAttribute('href')?.slice(1);
            if (href === current) {
              link.classList.add('active');
            } else {
              link.classList.remove('active');
            }
          });
        }
        
        // Smooth scroll with better positioning for categories
        tocLinks.forEach(link => {
          link.addEventListener('click', (e) => {
            e.preventDefault();
            const targetId = link.getAttribute('href')?.slice(1);
            if (!targetId) return;
            const targetElement = document.getElementById(targetId);
            
            if (targetElement) {
              // Better scroll positioning for categories
              const headerOffset = 80;
              const elementPosition = targetElement.getBoundingClientRect().top;
              const offsetPosition = elementPosition + window.pageYOffset - headerOffset;
              
              window.scrollTo({
                top: offsetPosition,
                behavior: 'smooth'
              });
            }
          });
        });
        
        // Initial highlight
        highlightTOC();
        
        // Update on scroll
        let ticking = false;
        window.addEventListener('scroll', () => {
          if (!ticking) {
            requestAnimationFrame(() => {
              highlightTOC();
              ticking = false;
            });
            ticking = true;
          }
        });
      });
    </script>
  </Fragment>
</BaseLayout>
)}
